// swift-tools-version: 6.0

import Foundation
import PackageDescription

// MARK: GENERATED
// ------------------------------------------------------------------------------------
let JSON = """
<%= json %>
"""
let DEPENDENCIES: [Package.Dependency] = [
<%= dependencies %>
]
let PLATFORMS: [SupportedPlatform] = [
<%= platforms %>
]
// ------------------------------------------------------------------------------------

// MARK: Main
if let data = JSON.data(using: .utf8),
   let dict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
   let dict = dict["targets"] as? [String: [String]] {
  _ = XCCache.Package(dict).spm
} else {
  _ = Package(name: "xccache")
}

// MARK: XCCache
enum XCCache {
  // MARK: Config
  @MainActor
  struct Config {
    static let knownSlugs: [String] = DEPENDENCIES.map(\.slug)
    static let pkgDir = URL(filePath: #filePath).deletingLastPathComponent()

    // NOTE: Do NOT change `binariesDir` to `static let`
    // Somehow, incremental resolution doesnt work causing the `binaryExist` wrongly cached
    static var binariesDir: URL { pkgDir.appending(path: "binaries") }
  }

  // MARK: Package
  @MainActor
  final class Package {
    let targets: [XCCache.Target]
    init(_ dict: [String: [String]]) {
      targets = dict.map { XCCache.Target($0, $1) }
    }

    var spm: PackageDescription.Package {
      let regularTargets = targets.map(\.spm)
      let binaryTargets = targets.flatMap(\.deps).compactMap(\.spmBinaryTarget).unique(by: \.name)
      return .init(
        name: "xccache",
        platforms: PLATFORMS,
        products: targets.map(\.spmProduct),
        dependencies: DEPENDENCIES,
        targets: regularTargets + binaryTargets
      )
    }
  }

  // MARK: Target
  @MainActor
  final class Target {
    let name: String
    let deps: [XCCache.Dependency]
    init(_ name: String, _ deps: [String]) {
      self.name = name
      self.deps = deps.map { XCCache.Dependency($0) }
    }

    var spmProduct: PackageDescription.Product {
      .library(name: name, targets: [name])
    }
    var spm: PackageDescription.Target {
      .target(
        name: name,
        dependencies: deps.compactMap(\.spm),
        path: ".Sources/\(name)"
      )
    }
    var spmBinaryTargets: [PackageDescription.Target] {
      deps.compactMap(\.spmBinaryTarget).unique(by: \.name)
    }
  }

  // MARK: Dependency
  @MainActor
  class Dependency {
    let name: String
    private let bareName: String
    private let binaryName: String

    init(_ name: String) {
      self.name = name
      self.bareName = name.basename.withoutExtenstion
      self.binaryName = bareName + ".xcframework"
    }

    private var isBinary: Bool { name.hasSuffix(".binary") }
    private var binaryExist: Bool { Config.binariesDir.appending(path: "\(bareName)/\(binaryName)").exist }
    private var isKnownSlug: Bool { Config.knownSlugs.contains(name.slug) }

    var spm: PackageDescription.Target.Dependency? {
      if isBinary && binaryExist { return .byName(name: name) }
      if isKnownSlug { return .product(name: name.basename.withoutBinary, package: name.slug) }
      return nil
    }
    var spmBinaryTarget: PackageDescription.Target? {
      isBinary && binaryExist ? .binaryTarget(name: name, path: "binaries/\(bareName)/\(binaryName)") : nil
    }
  }
}

// MARK: Helpers
extension Package.Dependency {
  var slug: String {
    switch kind {
    case let .registry(id: id, _): id
    case let .sourceControl(_, location: location, _): location.basename.withoutExtenstion
    case let .fileSystem(_, path: path): path.basename
    @unknown default: ""
    }
  }
}

extension URL {
  var exist: Bool { FileManager.default.fileExists(atPath: path()) }
}

extension String {
  var slug: String { (self as NSString).deletingLastPathComponent.basename }
  var basename: String { (self as NSString).lastPathComponent }
  var withoutExtenstion: String { (self as NSString).deletingPathExtension }
  var withoutBinary: String { replacing(#/\.binary$/#, with: "") }
}

extension Sequence {
  func unique<T: Hashable>(by: (Element) -> T) -> [Element] {
    var seen: Set<T> = []
    return filter { seen.insert(by($0)).inserted }
  }
}
